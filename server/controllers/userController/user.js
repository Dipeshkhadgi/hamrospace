import cloudinary from "cloudinary";
import sharp from "sharp";
import { NEW_REQUEST, REFETCH_CHATS } from "../../constants/event.js";
import { avatarStreamUpload } from "../../helpers/fileConvert.js";
import { generateOTP } from "../../helpers/generateOTP.js";
import { sendOTP } from "../../helpers/sendOTP.js";
import { getOtherMember } from "../../lib/helper.js";
import { tryCatchAsyncError } from "../../middlewares/tryCatchHandler.js";
import Chat from "../../models/chatModel/chat.js";
import Post from "../../models/postModel/post.js";
import Request from "../../models/requestModel/request.js";
import User from "../../models/userModel/user.js";
import ErrorHandler from "../../utils/errorHandler.js";
import { emitEvent } from "../../utils/features.js";
import sendEmail from "../../utils/sendEmail.js";

//register
export const register = tryCatchAsyncError(async (req, res, next) => {
  const { name, email, password, mobile_No, gender } = req.body;

  if (!name || !email || !password || !mobile_No || !gender) {
    return next(new ErrorHandler("All fields are required!", 400));
  }

  const phoneNumber = Number(mobile_No);
  if (
    !Number.isInteger(phoneNumber) ||
    phoneNumber < 1000000000 ||
    phoneNumber > 9999999999
  ) {
    return next(
      new ErrorHandler("Phone number must be a valid 10-digit number", 400)
    );
  }

  const exist = await User.findOne({ email });
  if (exist) {
    return next(new ErrorHandler("Email already exists!", 400));
  }

  const OTP = generateOTP();

  const user = await User.create({
    name,
    email,
    password,
    mobile_No,
    gender,
    otp: OTP,
    otp_expiry: new Date(Date.now() + 10 * 60 * 1000),
  });

  const userData = {
    _id: user._id,
    otp_expiry: user.otp_expiry,
    createdAt: user.createdAt,
  };

  // Send OTP via Email
  try {
    await sendEmail({
      email: user.email,
      subject: "Verification Code",
      message: `Dear ${user.name},\n\nOTP request action is triggered for your account.\n\nUse OTP code is: ${OTP}.\n\nDo not share your OTP with anyone.\n\nIf you face any difficulty during the registration process, do get in touch with our Support team.\n\nThis email was auto-generated by Supported Marketplace. Please do not reply to this mail.\n\nRegards,\n Supported Team`,
    });

    res.status(201).json({
      success: true,
      message: "OTP sent to email, verify account",
      data: userData,
    });
  } catch (error) {
    return next(new ErrorHandler("Failed to send OTP", 500));
  }
});

//Verify OTP
export const verifyAccount = tryCatchAsyncError(async (req, res, next) => {
  const otp = Number(req.body.otp);
  const userId = req.body.userId;
  if (!otp) {
    return next(new ErrorHandler("OTP is required!", 400));
  }

  const user = await User.findOne({ _id: userId });
  if (!user) {
    return next(new ErrorHandler("User not found!", 404));
  }

  if (!user.otp || !user.otp_expiry || new Date(user.otp_expiry) < new Date()) {
    return next(new ErrorHandler("OTP has expired", 400));
  }
  if (user.otp !== otp) {
    return next(new ErrorHandler("Invalid OTP", 400));
  }

  user.verified = true;
  user.otp = null;
  user.otp_expiry = null;
  await user.save();

  res.status(200).json({
    success: true,
    message: "Account verified successfully!",
    data: user,
  });
});

//resendOTP
export const resendOTP = tryCatchAsyncError(async (req, res, next) => {
  const { userId } = req.body;
  if (!userId) {
    return next(new ErrorHandler("UserId Does not exist!"));
  }

  try {
    const user = await User.findById(userId);
    if (!user) {
      return next(new ErrorHandler("User not found", 404));
    }

    //Check if the user is already verified
    if (user.verified) {
      return next(new ErrorHandler("Account already verified", 400));
    }

    //Generate new OTP and update user's document
    await sendOTP(user);
    const userData = {
      _id: user._id,
    };

    return res.status(201).json({
      success: true,
      message: "OTP sent to email, verify account",
      data: userData,
    });
  } catch (error) {
    return next(new ErrorHandler("Failed to resend OTP", 500));
  }
});

//login

// export const login = tryCatchAsyncError(async (req, res, next) => {
//   const { email, password } = req.body;

//   if (!email || !password) {
//     return next(new ErrorHandler("Field must be filled", 400));
//   }

//   const user = await User.findOne({ email }).select("+password");
//   if (!user) {
//     return next(new ErrorHandler("Email does not exist!", 400));
//   }

//   if (!user.verified) {
//     try {
//       await sendOTP(user);
//       return res.status(201).json({
//         success: true,
//         message: "OTP sent to email, verify account",
//       });
//     } catch (error) {
//       return next(new ErrorHandler("Failed to resend OTP", 500));
//     }
//   }

//   const isPasswordMatched = await user.comparePassword(password);
//   if (!isPasswordMatched) {
//     return next(new ErrorHandler("Invalid credentials!", 400));
//   }

//   // Generate tokens
//   const accessToken = user.generateAccessToken();
//   const refreshToken = user.generateRefreshToken();

//   // Send refreshToken as HTTP-only cookie
//   res.cookie("refreshToken", refreshToken, {
//     httpOnly: true,
//     secure: process.env.NODE_ENV === "production", // Set `true` in production
//     sameSite: "strict",
//   });

//   // Send response with accessToken
//   res.status(200).json({
//     success: true,
//     message: "Login Successfully!",
//     accessToken,
//     data: user,
//   });
// });

export const login = tryCatchAsyncError(async (req, res, next) => {
  const { email, password } = req.body;

  if (!email || !password) {
    return next(new ErrorHandler("Field must be filled", 400));
  }

  const user = await User.findOne({ email }).select("+password");
  if (!user) {
    return next(new ErrorHandler("Email does not exist!", 400));
  }

  // Check if user is locked
  if (user.isLocked()) {
    const waitTime = Math.ceil((user.lockUntil - Date.now()) / 60000);
    return next(new ErrorHandler(`Account locked. Try again in ${waitTime} minute(s).`, 403));
  }

  const isPasswordMatched = await user.comparePassword(password);
  if (!isPasswordMatched) {
    await user.incrementLoginAttempts();
    return next(new ErrorHandler("Invalid credentials!", 400));
  }

  // Reset failed attempts after successful login
  await user.resetLoginAttempts();

  if (!user.verified) {
    try {
      await sendOTP(user);
      return res.status(201).json({
        success: true,
        message: "OTP sent to email, verify account",
      });
    } catch (error) {
      return next(new ErrorHandler("Failed to resend OTP", 500));
    }
  }

  // Generate tokens
  const accessToken = user.generateAccessToken();
  const refreshToken = user.generateRefreshToken();

  res.cookie("refreshToken", refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
  });

  res.status(200).json({
    success: true,
    message: "Login Successfully!",
    accessToken,
    data: user,
  });
});


// Logout Controller
export const logout = (req, res) => {
  res.clearCookie("refreshToken");
  res.json({ message: "Logged out successfully" });
};

//change Password()
export const changePassword = tryCatchAsyncError(async (req, res, next) => {
  const user = await User.findById(req.user.id).select("+password");
  if (!user) {
    return next(new ErrorHandler("user is not found!", 404));
  }
  const { oldPassword, newPassword, confirmPassword } = req.body;
  if (!oldPassword || !newPassword || !confirmPassword) {
    return next(new ErrorHandler("all filed is required!", 400));
  }

  if (newPassword !== confirmPassword) {
    return next(new ErrorHandler("password must be match", 400));
  }

  const isMatch = await user.comparePassword(oldPassword);
  if (!isMatch) {
    return next(new ErrorHandler("oldPassword is incorrect", 400));
  }

  user.password = newPassword;
  await user.save();
  return res.status(200).json({
    success: true,
    message: "password changed successFully!",
  });
});
// Update Profile
export const updateProfile = tryCatchAsyncError(async (req, res, next) => {
  const user = await User.findById(req.user.id);
  if (!user) {
    return next(new ErrorHandler("User not found!", 404));
  }

  const { name, address, gender, dob } = req.body;

  const updatedData = { name, address, gender, dob };

  if (req.file) {
    try {
      const webpBuffer = await sharp(req.file.buffer)
        .webp({ quality: 80 })
        .toBuffer();

      const result = await avatarStreamUpload(webpBuffer);

      updatedData.avatar = {
        url: result.secure_url,
        public_id: result.public_id,
      };

      // Delete the previous avatar from Cloudinary if it exists
      if (user.avatar && user.avatar.public_id) {
        await cloudinary.v2.uploader.destroy(user.avatar.public_id);
      }
    } catch (error) {
      return next(new ErrorHandler("Error updating avatar image.", 500));
    }
  }

  // Update user data
  Object.assign(user, updatedData);
  await user.save();

  res.status(200).json({
    success: true,
    message: "Profile updated successfully",
    data: user,
  });
});

//myProfile
export const getProfile = tryCatchAsyncError(async (req, res, next) => {
  const user = await User.findById(req.user.id).populate(
    "posts followers following"
  );
  if (!user) return next(new ErrorHandler("User not found!", 404));

  res.status(200).json({
    success: true,
    message: "User fetch successFully!",
    data: user,
  });
});

//searchUser
export const searchUser = tryCatchAsyncError(async (req, res, next) => {
  const { name } = req.query;

  const myChats = await Chat.find({ groupChat: false, members: req.user.id });
  const allUsersFromMyChats = myChats.flatMap((chat) => chat.members);

  const allUsersExceptMeAndFriends = await User.find({
    _id: { $nin: allUsersFromMyChats },
    name: { $regex: name, $options: "i" },
  });

  const users = allUsersExceptMeAndFriends.map(
    ({ _id, name, avatar, posts }) => ({
      _id,
      name,
      avatar: avatar.url,
      postsCount: posts.length,
    })
  );

  res.status(200).json({
    success: true,
    data: users,
  });
});
//forgotPassword

export const forgotPassword = tryCatchAsyncError(async (req, res, next) => {
  const { email } = req.body;

  if (!email) {
    return next(new ErrorHandler("Email is required", 400));
  }

  const user = await User.findOne({ email });
  if (!user) {
    return next(new ErrorHandler("User not found", 404));
  }

  try {
    const resetOTP = user.findResetPasswordOTP();
    await user.save();

    const ValidData = {
      email: user.email,
      _id: user._id,
    };

    await sendEmail({
      email: user.email,
      subject: "Password Reset Code",
      message: `Dear ${user.name},\n\nPassword reset action is triggered for your account.\n\nUse the following OTP to reset your password: ${resetOTP}.\n\nThis OTP is valid for 10 minutes.\n\nIf you did not request this, please ignore this email.\n\nThis email was auto-generated by Supported Marketplace. Please do not reply to this mail.\n\nRegards,\nSupported Team`,
    });

    res.status(200).json({
      success: true,
      message: `An email has been sent to: ${user.email}. Please check your inbox and spam folder.`,
      data: ValidData,
    });
  } catch (error) {
    user.resetPasswordOtp = undefined;
    user.resetPasswordOtpExpiry = undefined;
    await user.save();

    return next(
      new ErrorHandler("Unable to send reset email. Try again later.", 500)
    );
  }
});

export const resetOTPRecovery = tryCatchAsyncError(async (req, res, next) => {
  const { email, userId, otp } = req.body;

  // Check if required fields are provided
  if (!email || !userId || !otp) {
    return next(new ErrorHandler("Please provide OTP,", 400));
  }

  // Find user by email and userId, also check OTP and its expiry
  const user = await User.findOne({
    _id: userId,
    email: email,
    resetPasswordOtp: otp,
    resetPasswordOtpExpiry: { $gt: Date.now() }, // Ensure OTP hasn't expired
  });

  // If user is not found or OTP is invalid/expired
  if (!user) {
    return next(new ErrorHandler("Invalid OTP, or OTP expired", 400));
  }

  // Clear OTP and expiry to prevent reuse
  user.resetPasswordOtp = undefined;
  user.resetPasswordOtpExpiry = undefined;

  // Save the updated user
  await user.save();
  const userData = {
    email: user.email,
    _id: user._id,
  };

  // Send response
  res.status(200).json({
    success: true,
    message: "OTP verified Success!",
    data: userData,
  });
});

//resetPassword
export const resetPassword = tryCatchAsyncError(async (req, res, next) => {
  const { userId, newPassword, confirmPassword } = req.body;

  if (!userId || !newPassword || !confirmPassword) {
    return next(new ErrorHandler("Invalid Data format!", 400));
  }

  if (newPassword.length < 8 || confirmPassword.length < 8) {
    return next(
      new ErrorHandler("Password must be at least 8 characters long", 400)
    );
  }

  if (newPassword !== confirmPassword) {
    return next(new ErrorHandler("Passwords do not match", 400));
  }

  // Find user by email and userId, also check OTP and its expiry
  const user = await User.findOne({
    _id: userId,
  });

  if (!user) {
    return next(new ErrorHandler("Invalid or expired OTP", 400));
  }

  user.password = newPassword;

  await user.save();

  res.status(200).json({
    success: true,
    message: "Password has been reset successfully!",
  });
});

//sendFriendRequest
export const sendFriendRequest = tryCatchAsyncError(async (req, res, next) => {
  const { receiverId } = req.body;
  if (!receiverId) {
    return next(new ErrorHandler("ReceiverId is required", 400));
  }
  const request = await Request.findOne({
    $or: [
      { sender: req.user.id, receiver: receiverId },
      { sender: receiverId, receiver: req.user.id },
    ],
  });
  if (request) {
    return next(new ErrorHandler("Request already sent", 400));
  }

  await Request.create({
    sender: req.user.id,
    receiver: receiverId,
  });

  emitEvent(req, NEW_REQUEST, [receiverId]);
  return res.status(200).json({
    success: true,
    message: "Friend Request sent",
  });
});

//acceptFriendRequest
export const acceptFriendRequest = tryCatchAsyncError(
  async (req, res, next) => {
    const { requestId, accept } = req.body;
    if (!requestId) {
      return next(new ErrorHandler("RequestId is required", 400));
    }
    const request = await Request.findById(requestId)
      .populate("sender", "name,avatar")
      .populate("receiver", "name,avatar");
    if (!request) {
      return next(new ErrorHandler("Request not found", 404));
    }
    if (request.receiver._id.toString() !== req.user.id.toString()) {
      return next(new ErrorHandler("Unauthorized access", 403));
    }

    if (!accept) {
      await request.deleteOne();

      return res.status(200).json({
        success: true,
        message: "Friend Request rejected",
      });
    }

    const members = [request.sender._id, request.receiver._id];
    await Promise.all([
      Chat.create({
        members,
        name: `${request.sender.name}-${request.receiver.name}`,
      }),
      request.deleteOne(),
    ]);
    emitEvent(req, REFETCH_CHATS, members);

    return res.status(200).json({
      success: true,
      message: "Friend Request accepted",
      senderId: request.sender._id,
    });
  }
);

//get all Notifications
export const getMyNotifications = tryCatchAsyncError(async (req, res) => {
  const requests = await Request.find({ receiver: req.user.id }).populate(
    "sender",
    "name avatar"
  );

  const allRequests = requests.map(({ _id, sender }) => {
    return {
      _id,
      sender: {
        _id: sender?._id || null,
        name: sender?.name || "Unknown",
        avatar: sender?.avatar?.url,
      },
    };
  });

  res.status(200).json({
    success: true,
    data: allRequests,
  });
});

//get My friends
export const getMyFriends = tryCatchAsyncError(async (req, res) => {
  const chatId = req.query.chatId;

  const chats = await Chat.find({
    members: req.user.id,
    groupChat: false,
  }).populate("members", "name,avatar");
  const friends = chats.map(({ members }) => {
    const otherUser = getOtherMember(members, req.user.id);
    return {
      _id: otherUser._id,
      name: otherUser.name,
      avatar: otherUser.avatar.url,
    };
  });

  if (chatId) {
    const chat = await Chat.findById(chatId);
    const availabeFriends = friends.filter(
      (friend) => !chat.members.includes(friend._id)
    );
    return res.status(200).json({
      success: true,
      data: availabeFriends,
    });
  } else {
    res.status(200).json({
      success: true,
      data: friends,
    });
  }
});

//follow User
export const followUser = tryCatchAsyncError(async (req, res, next) => {
  const userToFollow = await User.findById(req.params.id);
  const loggedInUser = await User.findById(req.user.id);

  if (!userToFollow) return next(new ErrorHandler("User not found!", 404));

  // Check if the loggedInUser is already following userToFollow
  const isAlreadyFollowing = loggedInUser.following.includes(userToFollow._id);

  if (isAlreadyFollowing) {
    // Unfollow the user
    const indexFollowing = loggedInUser.following.indexOf(userToFollow._id);
    const indexFollowers = userToFollow.followers.indexOf(loggedInUser.id);

    loggedInUser.following.splice(indexFollowing, 1);
    userToFollow.followers.splice(indexFollowers, 1);
  } else {
    // Follow the user
    loggedInUser.following.push(userToFollow._id);
    userToFollow.followers.push(loggedInUser.id);
  }

  await loggedInUser.save();
  await userToFollow.save();

  res.status(200).json({
    success: true,
    message: isAlreadyFollowing ? "User unfollowed!" : "User followed!",
    data: loggedInUser,
  });
});

//deleteProfile(By Admin)
export const deleteProfile = async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id);

    if (!user) {
      return next(new ErrorHandler("User not found!", 404));
    }

    const userId = user._id;

    // Delete the user's avatar from Cloudinary
    if (user.avatar?.public_id) {
      await cloudinary.v2.uploader.destroy(user.avatar.public_id);
    }

    // Fetch user's posts and delete associated images and posts
    const postsToDelete = await Post.find({ _id: { $in: user.posts } });
    const deletePostPromises = postsToDelete.map(async (post) => {
      if (post.postImg?.public_id) {
        await cloudinary.v2.uploader.destroy(post.postImg.public_id);
      }
      return post.deleteOne();
    });

    await Promise.all(deletePostPromises);

    // Remove the user from followers' following and followings' followers
    const followerUpdatePromises = user.followers.map((followerId) =>
      User.findByIdAndUpdate(
        followerId,
        { $pull: { following: userId } },
        { new: true }
      )
    );

    const followingUpdatePromises = user.following.map((followingId) =>
      User.findByIdAndUpdate(
        followingId,
        { $pull: { followers: userId } },
        { new: true }
      )
    );

    await Promise.all([...followerUpdatePromises, ...followingUpdatePromises]);

    // Remove user's comments and likes from all posts
    const allPosts = await Post.find();
    const updatePostsPromises = allPosts.map((post) => {
      const originalCommentCount = post.comments.length;
      post.comments = post.comments.filter(
        (comment) => comment.user.toString() !== userId.toString()
      );

      const originalLikesCount = post.likes.length;
      post.likes = post.likes.filter(
        (likeId) => likeId.toString() !== userId.toString()
      );

      if (
        post.comments.length !== originalCommentCount ||
        post.likes.length !== originalLikesCount
      ) {
        return post.save();
      }
    });

    await Promise.all(updatePostsPromises);

    // Delete the user account
    await user.deleteOne();

    // Clear the authentication token
    res.cookie("token", null, { expires: new Date(0), httpOnly: true });

    res.status(200).json({
      success: true,
      message: "Profile deleted successfully!",
    });
  } catch (err) {
    next(err);
  }
};

//getAllUserPost
export const userPosts = tryCatchAsyncError(async (req, res, next) => {
  const user = await User.findById(req.params.id);

  const posts = [];

  for (let i = 0; i < user.posts.length; i++) {
    const post = await Post.findById(user.posts[i]).populate(
      "likes comments.user owner"
    );
    posts.push(post);
  }

  res.status(200).json({
    success: true,
    data: posts,
  });
});
